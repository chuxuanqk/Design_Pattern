#include <stdio.h>


/*
图的存储结构:
数组表示法(邻接矩阵):有向图和无向图的顺序存储 
邻接表(Adjacency List):有向图和无向图的链式存储 
十字链表(Orthogonal List):是有向图的另一种链式存储结构 
邻接多重表(Adjacency Multilist):是无向图的另一种链式存储结构。 

图的基本操作:
(独立于图的存储结构, 不同的存储方式，操作算法的具体实现会有着不同的性能) 
考虑不同的存储方式，具体算法的实现，以及采用何种存储方式的算法效率会更高
 Adjacent(G, x, y);		判断图G是否存在边<x, y>或(x, y)
 Neighbors(G, x);		列出图G中与结点x邻接的边
 InsertVertex(G, x);	在图G中插入顶点x
 DeleteVertex(G, x);	从图G中删除顶点x
 AddEdge(G, x, y);		如果无向边(x, y) 或有向边<x, y>不存在，则向图G中添加该边
 RemoveEdge(G, x, y); 	如果无向边(x, y) 或有向边<x, y>存在，则从图G中删除该边
 FirstNeighbot(G, x);	求图G中顶点x的第一个邻接点，若有则返回顶点号。
 						若x没有邻接点或图中不存在x，则返回-1
 NextNeighbor(G, x, y); 假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的
 						下一个邻接点a的顶点号，若y是x的最后一个邻接点，则返回-1
 Get_edge_value(G, x, y);获取图G中边(x, y)或<x, y>对应的权值
 Set_edge_value(G, x, y， v);设置图G中边(x, y)或<x, y>对应的权值为v
 图的遍历算算法			按照某种方式访问图中每一个顶点且仅访问一次。
 						(包括深度优先遍历和广度优先遍历) 


DFS的具体实现:
基本概念:  连通分量， 强连通分量
G(V,E) : V---顶点的有穷非空集合，E---顶点之间的一条边 
连通分量: 在无向图中，如果两个顶点间可以互相到达(可以是通过一定路径间接到达)，
		那么就称这两个顶点连通。 如果图G(V,E)的任意两个顶点都连通，则称图G为连通图；
		否则，称G为非连通图，且称其中的极大连通子图为连通分量。
		
强连通分量: 在有向图中，如果两个顶点可以各自通过一条有向路径到达另一个顶点，
			就称这两个顶点强连通。如果图G(V,E)的任意两个顶点都强连通，则称图G为强连通图；
			否则，称图G为非强连通图，且称其中的极大强连通子图为强连通分量。		
*/

const int MAXV = 1000;			// 最大顶点数
const int INF  = 1000000000; 	// 设INF为一个很大的数


/*图的数组存储(邻接矩阵)*/
int n, G[MAXV][MAXV];		// n 为顶点数， MAXV为最大顶点数
bool vis[MAXV] = {false};	// 如果顶点i已被访问，则vis[i]==true.初值为false


/****************************************
函数名: 	DFS
函数功能:	深度遍历 
输入: 	u 		当前访问的顶点标号， 
		depth  	深度 
输出:
*****************************************/ 
void DFS(int u, int depth){
	int v=0;
	vis[u] = true;			// 设置u已被访问
	// 如果需要对u进行一些操作，可以在这里进行
	// 下面对所有从u出发能到达的分支进行枚举
	for(v=0; v<n; v++){	//对每个顶点v
		if(vis[v] == false && G[u][v] != INF) 	//如果v未被访问，且u可达到v 
			DFS(v, depth+1); 
	}	
}	  

/****************************************
函数名: 	DFSTrave
函数功能:	图深度遍历 
输入: 	
输出: 
*****************************************/ 
void DFSTrave(){
	int u=0;
	for(int u=0; u<n; u++){ 	// 对每个顶点u
		 if(vis[u] == false)	// 如果u未被访问	
		 	DFS(u, 1); 			// 访问u和u所在的连通块， 1表示初始为第一层 
	}
}

 



 
 
